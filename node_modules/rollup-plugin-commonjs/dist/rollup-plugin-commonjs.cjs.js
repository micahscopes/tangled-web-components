'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = require('fs');
var path = require('path');
var resolve$1 = require('resolve');
var acorn = _interopDefault(require('acorn'));
var estreeWalker = require('estree-walker');
var MagicString = _interopDefault(require('magic-string'));
var rollupPluginutils = require('rollup-pluginutils');

function isReference ( node, parent ) {
	if ( parent.type === 'MemberExpression' ) return parent.computed || node === parent.object;

	// disregard the `bar` in { bar: foo }
	if ( parent.type === 'Property' && node !== parent.value ) return false;

	// disregard the `bar` in `class Foo { bar () {...} }`
	if ( parent.type === 'MethodDefinition' ) return false;

	// disregard the `bar` in `export { foo as bar }`
	if ( parent.type === 'ExportSpecifier' && node !== parent.local ) return false;

	return true;
}

function flatten ( node ) {
	var name;
	var parts = [];

	while ( node.type === 'MemberExpression' ) {
		if ( node.computed ) return null;

		parts.unshift( node.property.name );
		node = node.object;
	}

	if ( node.type !== 'Identifier' ) return null;

	name = node.name;
	parts.unshift( name );

	return { name: name, keypath: parts.join( '.' ) };
}

var firstpassGlobal = /\b(?:require|module|exports|global)\b/;
var firstpassNoGlobal = /\b(?:require|module|exports)\b/;
var exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;

var reserved = 'abstract arguments boolean break byte case catch char class const continue debugger default delete do double else enum eval export extends false final finally float for function goto if implements import in instanceof int interface let long native new null package private protected public return short static super switch synchronized this throw throws transient true try typeof var void volatile while with yield'.split( ' ' );

var blacklistedExports = { __esModule: true };
reserved.forEach( function (word) { return blacklistedExports[ word ] = true; } );

function getName ( id ) {
	var base = path.basename( id );
	var ext = path.extname( base );

	return rollupPluginutils.makeLegalIdentifier( ext.length ? base.slice( 0, -ext.length ) : base );
}

function getCandidatesForExtension ( resolved, extension ) {
	return [
		resolved + extension,
		resolved + path.sep + "index" + extension
	];
}

function getCandidates ( resolved, extensions ) {
	return extensions.reduce(
		function ( paths, extension ) { return paths.concat( getCandidatesForExtension ( resolved, extension ) ); },
		[resolved]
	);
}

function deconflict ( identifier, code ) {
	var i = 1;
	var deconflicted = identifier;

	while ( ~code.indexOf( deconflicted ) ) deconflicted = identifier + "_" + (i++);
	return deconflicted;
}

var HELPERS_ID = '\0commonjsHelpers';
var HELPERS = "\nexport var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}\n\nexport function interopDefault(ex) {\n\treturn ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nexport function createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}";

function commonjs ( options ) {
	if ( options === void 0 ) options = {};

	var extensions = options.extensions || ['.js'];
	var filter = rollupPluginutils.createFilter( options.include, options.exclude );
	var ignoreGlobal = options.ignoreGlobal;
	var firstpass = ignoreGlobal ? firstpassNoGlobal : firstpassGlobal;

	var sourceMap = options.sourceMap !== false;

	var customNamedExports = {};
	if ( options.namedExports ) {
		Object.keys( options.namedExports ).forEach( function (id) {
			var resolvedId;

			try {
				resolvedId = resolve$1.sync( id, { basedir: process.cwd() });
			} catch ( err ) {
				resolvedId = path.resolve( id );
			}

			customNamedExports[ resolvedId ] = options.namedExports[ id ];
		});
	}

	return {
		name: 'commonjs',

		resolveId: function resolveId ( importee, importer ) {
			if ( importee === HELPERS_ID ) return importee;
			if ( importee[0] !== '.' || !importer ) return; // not our problem

			var resolved = path.resolve( path.dirname( importer ), importee );
			var candidates = getCandidates( resolved, extensions );

			for ( var i = 0; i < candidates.length; i += 1 ) {
				try {
					var stats = fs.statSync( candidates[i] );
					if ( stats.isFile() ) return candidates[i];
				} catch ( err ) { /* noop */ }
			}
		},

		load: function load ( id ) {
			if ( id === HELPERS_ID ) return HELPERS;
		},

		transform: function transform ( code, id ) {
			if ( !filter( id ) ) return null;
			if ( extensions.indexOf( path.extname( id ) ) === -1 ) return null;
			if ( !firstpass.test( code ) ) return null;

			var ast;

			try {
				ast = acorn.parse( code, {
					ecmaVersion: 6,
					sourceType: 'module'
				});
			} catch ( err ) {
				err.message += " in " + id;
				throw err;
			}

			var magicString = new MagicString( code );

			var required = {};
			// Because objects have no guaranteed ordering, yet we need it,
			// we need to keep track of the order in a array
			var sources = [];
			
			var uid = 0;

			var scope = rollupPluginutils.attachScopes( ast, 'scope' );
			var uses = { module: false, exports: false, global: false };

			var namedExports = {};
			if ( customNamedExports[ id ] ) {
				customNamedExports[ id ].forEach( function (name) { return namedExports[ name ] = true; } );
			}

			var scopeDepth = 0;

			var HELPERS_NAME = deconflict( 'commonjsHelpers', code );

			estreeWalker.walk( ast, {
				enter: function enter ( node, parent ) {
					if ( node.scope ) scope = node.scope;
					if ( /^Function/.test( node.type ) ) scopeDepth += 1;

					if ( sourceMap ) {
						magicString.addSourcemapLocation( node.start );
						magicString.addSourcemapLocation( node.end );
					}

					// Is this an assignment to exports or module.exports?
					if ( node.type === 'AssignmentExpression' ) {
						if ( node.left.type !== 'MemberExpression' ) return;

						var flattened = flatten( node.left );
						if ( !flattened ) return;

						if ( scope.contains( flattened.name ) ) return;

						var match = exportsPattern.exec( flattened.keypath );
						if ( !match || flattened.keypath === 'exports' ) return;

						if ( flattened.keypath === 'module.exports' && node.right.type === 'ObjectExpression' ) {
							return node.right.properties.forEach( function (prop) {
								if ( prop.computed || prop.key.type !== 'Identifier' ) return;
								var name = prop.key.name;
								if ( name === rollupPluginutils.makeLegalIdentifier( name ) ) namedExports[ name ] = true;
							});
						}

						if ( match[1] ) namedExports[ match[1] ] = true;

						return;
					}

					// To allow consumption of UMD modules, transform `typeof require` to `'function'`
					if ( node.type === 'UnaryExpression' && node.operator === 'typeof' && node.argument.type === 'Identifier' ) {
						var name$1 = node.argument.name;

						if ( name$1 === 'require' && !scope.contains( name$1 ) ) {
							magicString.overwrite( node.start, node.end, "'function'" );
							return;
						}
					}

					if ( node.type === 'Identifier' ) {
						if ( ( node.name in uses ) && isReference( node, parent ) && !scope.contains( node.name ) ) {
							uses[ node.name ] = true;
							if ( node.name === 'global' ) magicString.overwrite( node.start, node.end, (HELPERS_NAME + ".commonjsGlobal") );
						}
						return;
					}

					if ( node.type === 'ThisExpression' && scopeDepth === 0 && !ignoreGlobal ) {
						uses.global = true;
						magicString.overwrite( node.start, node.end, (HELPERS_NAME + ".commonjsGlobal"), true );
						return;
					}

					if ( node.type !== 'CallExpression' ) return;
					if ( node.callee.name !== 'require' || scope.contains( 'require' ) ) return;
					if ( node.arguments.length !== 1 || node.arguments[0].type !== 'Literal' ) return; // TODO handle these weird cases?

					var source = node.arguments[0].value;

					var existing = required[ source ];
					if ( existing === undefined ) {
						sources.unshift(source);
					}
					var name;

					if ( !existing ) {
						name = "require$$" + (uid++);
						required[ source ] = { source: source, name: name, importsDefault: false };
					} else {
						name = required[ source ].name;
					}

					if ( parent.type !== 'ExpressionStatement' ) {
						required[ source ].importsDefault = true;
						magicString.overwrite( node.start, node.end, (HELPERS_NAME + ".interopDefault(" + name + ")") );
					} else {
						// is a bare import, e.g. `require('foo');`
						magicString.remove( parent.start, parent.end );
					}
				},

				leave: function leave ( node ) {
					if ( node.scope ) scope = scope.parent;
					if ( /^Function/.test( node.type ) ) scopeDepth -= 1;
				}
			});

			if ( !sources.length && !uses.module && !uses.exports && !uses.global ) {
				if ( Object.keys( namedExports ).length ) {
					throw new Error( ("Custom named exports were specified for " + id + " but it does not appear to be a CommonJS module") );
				}
				return null; // not a CommonJS module
			}

			var name = getName( id );

			var importBlock = [ ("import * as " + HELPERS_NAME + " from '" + HELPERS_ID + "';") ].concat(
				sources.map( function (source) {
					var ref = required[ source ];
					var name = ref.name;
					var importsDefault = ref.importsDefault;
					return ("import " + (importsDefault ? ("* as " + name + " from ") : "") + "'" + source + "';");
				})
			).join( '\n' );

			var args = "module" + (uses.exports ? ', exports' : '');

			var intro = "\n\nvar " + name + " = " + HELPERS_NAME + ".createCommonjsModule(function (" + args + ") {\n";
			var outro = "\n});\n\nexport default " + HELPERS_NAME + ".interopDefault(" + name + ");\n";

			outro += Object.keys( namedExports )
				.filter( function (key) { return !blacklistedExports[ key ]; } )
				.map( function (x) {
					if (x === name) {
						return ("var " + x + "$$1 = " + name + "." + x + ";\nexport { " + x + "$$1 as " + x + " };");
					} else {
						return ("export var " + x + " = " + name + "." + x + ";");
					}
				})
				.join( '\n' );

			magicString.trim()
				.prepend( importBlock + intro )
				.trim()
				.append( outro );

			code = magicString.toString();
			var map = sourceMap ? magicString.generateMap() : null;

			return { code: code, map: map };
		}
	};
}

module.exports = commonjs;